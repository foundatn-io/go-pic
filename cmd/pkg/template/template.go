package template

import (
	"bytes"
	"fmt"
	"reflect"
	"regexp"
	"text/template"

	"github.com/foundatn-io/go-pic/pkg/lex"
)

var (
	special = regexp.MustCompile("[^a-zA-Z0-9]+")
)

type state struct {
	newStart   int
	newEnd     int
	savedStart int
	savedEnd   int
	cursor     int
	structs    []string
}

func Copybook() *template.Template {
	ts := newTemplateState()
	return ts.parseTemplate()
}

func newTemplateState() *state {
	return &state{
		newStart:   1,
		newEnd:     1,
		savedStart: 1,
		savedEnd:   1,
		cursor:     1,
		structs:    make([]string, 0),
	}
}

func (ts *state) getTemplateFuncs() template.FuncMap {
	return template.FuncMap{
		"goType":       goType,
		"isStruct":     isStruct,
		"sanitiseName": sanitiseName,
		"picTag":       ts.newPicTag,
		"indexComment": ts.indexComment,
		"buildStruct":  ts.buildStruct,
		"getStructs":   ts.getStructs,
	}
}

func (ts *state) newPicTag(length int, elemCount int) string {
	size := ts.calculateSize(length, elemCount)
	start := ts.newStart
	end := start + (size - 1)

	// manipulate state
	ts.newEnd = end
	ts.newStart = ts.newEnd + 1
	if elemCount > 0 {
		return "`" + fmt.Sprintf("pic:\"%d,%d,%d\"", start, end, elemCount) + "`"
	}

	return "`" + fmt.Sprintf("pic:\"%d,%d\"", start, end) + "`"
}

// FIXME: (pgmitche) index comments are being over-calculated now,
// due to struct support.
// e.g. DUMMYGROUP1's length of 63 is being calculated 3x to 1+189
// so DUMMYGROUP3 now starts at 201, instead of 64
//
//	type root struct {
//		DUMMYGROUP1 DUMMYGROUP1 `pic:"63"`  // start:1 end:63
//		DUMMYGROUP3 DUMMYGROUP3 `pic:"201"` // start:190 end:390
//	}
func (ts *state) indexComment(length int, elemCount int) string {
	size := ts.calculateSize(length, elemCount)
	s := ts.cursor
	e := s + size
	ts.cursor = e
	return fmt.Sprintf(" // start:%d end:%d", s, e-1)
}

func (ts *state) calculateSize(length int, elemCount int) int {
	size := length
	if elemCount > 0 {
		size *= elemCount
	}
	return size
}

func (ts *state) buildStruct(r *lex.Record) string {
	ts.savedStart = ts.newStart
	ts.savedEnd = ts.newEnd
	b := bytes.Buffer{}
	if err := ts.getStructTemplate().Execute(&b, r); err != nil {
		panic(fmt.Errorf("execute struct templte: %w", err))
	}
	ts.structs = append(ts.structs, b.String())
	ts.newStart = ts.savedStart
	ts.newEnd = ts.savedEnd
	return ""
}

func (ts *state) getStructs() []string {
	return ts.structs
}

// FIXME: (pgmitche) if record is struct but has no children,
// it should probably be ignored entirely
func (ts *state) getStructTemplate() *template.Template {
	ts.newStart = 1
	ts.newEnd = 1

	t, err := template.New("struct").
		Funcs(ts.getTemplateFuncs()).
		Parse(`
// {{ sanitiseName .Name }} contains a representation of the nested group {{ .Name }}
type {{ sanitiseName .Name }} struct {
	{{- range $element := .Children}}
		{{- if isStruct $element }}
			{{ sanitiseName $element.Name }} {{ goType $element -}} {{ picTag $element.Length $element.Occurs}} 
            {{- buildStruct $element }} 
		{{- else }}
			{{ sanitiseName $element.Name }} {{ goType $element }} {{ picTag $element.Length $element.Occurs}} {{ indexComment $element.Length $element.Occurs -}}
		{{- end }}
	{{- end }}
}`)
	if err != nil {
		panic(err)
	}
	return t
}

func (ts *state) parseTemplate() *template.Template {
	return template.Must(
		template.New("root").
			Funcs(ts.getTemplateFuncs()).
			Parse(`
////////////////////////////////
//     AUTOGENERATED FILE     //
// File generated with go-pic //
////////////////////////////////

// nolint
package {{ .Package }}

// {{ .Root.Name }} contains a representation of your provided Copybook
type {{ .Root.Name }} struct {
	{{- range $element := .Root.Children}}
		{{- if isStruct $element }}
			{{- sanitiseName $element.Name }} {{ goType $element }} {{ picTag $element.Length $element.Occurs}}
            {{- buildStruct $element }} 
		{{ else }}
			{{ sanitiseName $element.Name }} {{ goType $element }} {{ picTag $element.Length $element.Occurs}}{{ indexComment $element.Length $element.Occurs -}} 
		{{- end }}
	{{- end }}
}

{{- range $elem := getStructs }}
	{{ $elem }}
{{- end }}
`))
}

// goType translates a type into a go type
func goType(l *lex.Record) string {
	tag := ""
	switch l.Typ {
	case reflect.String:
		tag = "string"
	case reflect.Int:
		tag = "int"
	case reflect.Uint:
		tag = "uint"
	case reflect.Float64:
		tag = "float64"
	case reflect.Struct:
		tag = sanitiseName(l.Name)
	default:
		panic(fmt.Errorf("unrecognized type %v", l.Typ))
	}
	if l.Occurs > 0 {
		tag = fmt.Sprintf("[]%s", tag)
	}
	return tag
}

func sanitiseName(s string) string {
	return special.ReplaceAllString(s, "")
}

func isStruct(r *lex.Record) bool {
	return r.Typ == reflect.Struct
}
