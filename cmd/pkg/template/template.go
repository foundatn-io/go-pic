package template

import (
	"bytes"
	"fmt"
	"reflect"
	"regexp"
	"text/template"

	"github.com/foundatn-io/go-pic/pkg/lex"
)

const (
	stringTag = "string"
	intTag    = "int"
	uintTag   = "uint"
	floatTag  = "float64"
)

// specialCharsRegexp is a regular expression that matches any character that is not alphanumeric.
var specialCharsRegexp = regexp.MustCompile("[^a-zA-Z0-9]+")

// state holds the state of the template.
type state struct {
	newStartPosition   int
	newEndPosition     int
	savedStartPosition int
	savedEndPosition   int
	cursor             int
	structs            []string
}

func Copybook() *template.Template {
	ts := newTemplateState()
	return ts.createParsedTemplate()
}

// newTemplateState creates a new state.
func newTemplateState() *state {
	return &state{
		newStartPosition:   1,
		newEndPosition:     1,
		savedStartPosition: 1,
		savedEndPosition:   1,
		cursor:             1,
		structs:            make([]string, 0),
	}
}

// createTemplateFuncMap returns a map of functions that can be used in the template.
func (ts *state) createTemplateFuncMap() template.FuncMap {
	return template.FuncMap{
		"translateToGoType":    translateToGoType,
		"checkIfStruct":        checkIfStruct,
		"sanitiseName":         sanitiseName,
		"generatePicTag":       ts.generatePicTag,
		"generateIndexComment": ts.generateIndexComment,
		"constructStruct":      ts.constructStruct,
		"retrieveStructs":      ts.retrieveStructs,
	}
}

// generatePicTag generates a new PIC tag.
func (ts *state) generatePicTag(length int, elemCount int) string {
	size := ts.calculateElementSize(length, elemCount)
	start := ts.newStartPosition
	end := start + (size - 1)

	// manipulate state
	ts.newEndPosition = end
	ts.newStartPosition = ts.newEndPosition + 1
	if elemCount > 0 {
		return "`" + fmt.Sprintf("pic:\"%d,%d,%d\"", start, end, elemCount) + "`"
	}

	return "`" + fmt.Sprintf("pic:\"%d,%d\"", start, end) + "`"
}

// generateIndexComment generates a comment for the index.
// FIXME: (pgmitche) index comments are being over-calculated now,
// due to struct support.
// e.g. DUMMYGROUP1's length of 63 is being calculated 3x to 1+189
// so DUMMYGROUP3 now starts at 201, instead of 64
//
//	type root struct {
//		DUMMYGROUP1 DUMMYGROUP1 `pic:"63"`  // start:1 end:63
//		DUMMYGROUP3 DUMMYGROUP3 `pic:"201"` // start:190 end:390
//	}
func (ts *state) generateIndexComment(length int, elemCount int) string {
	size := ts.calculateElementSize(length, elemCount)
	s := ts.cursor
	e := s + size
	ts.cursor = e
	return fmt.Sprintf(" // start:%d end:%d", s, e-1)
}

// calculateElementSize calculates the size of the element.
func (ts *state) calculateElementSize(length int, elemCount int) int {
	size := length
	if elemCount > 0 {
		size *= elemCount
	}
	return size
}

// constructStruct builds a struct from a record.
func (ts *state) constructStruct(r *lex.Record) string {
	ts.savedStartPosition = ts.newStartPosition
	ts.savedEndPosition = ts.newEndPosition
	b := bytes.Buffer{}
	if err := ts.createStructTemplate().Execute(&b, r); err != nil {
		panic(fmt.Errorf("execute struct templte: %w", err))
	}
	ts.structs = append(ts.structs, b.String())
	ts.newStartPosition = ts.savedStartPosition
	ts.newEndPosition = ts.savedEndPosition
	return ""
}

// retrieveStructs returns the structs.
func (ts *state) retrieveStructs() []string {
	return ts.structs
}

// createStructTemplate returns the template for a struct.
func (ts *state) createStructTemplate() *template.Template {
	ts.newStartPosition = 1
	ts.newEndPosition = 1

	t, err := template.New("struct").
		Funcs(ts.createTemplateFuncMap()).
		Parse(`
// {{ sanitiseName .Name }} contains a representation of the nested group {{ .Name }}
type {{ sanitiseName .Name }} struct {
	{{- range $element := .Children}}
		{{- if checkIfStruct $element }}
			{{ sanitiseName $element.Name }} {{ translateToGoType $element -}} {{ generatePicTag $element.Length $element.Occurs}}
            {{- constructStruct $element }}
		{{- else }}
			{{ sanitiseName $element.Name }} {{ translateToGoType $element }} {{ generatePicTag $element.Length $element.Occurs}} {{ generateIndexComment $element.Length $element.Occurs -}}
		{{- end }}
	{{- end }}
}`)
	if err != nil {
		panic(err)
	}
	return t
}

// createParsedTemplate parses the template.
func (ts *state) createParsedTemplate() *template.Template {
	return template.Must(
		template.New("root").
			Funcs(ts.createTemplateFuncMap()).
			Parse(`
////////////////////////////////
//     AUTOGENERATED FILE     //
// File generated with go-pic //
////////////////////////////////

// nolint
package {{ .Package }}

// {{ .Root.Name }} contains a representation of your provided Copybook
type {{ .Root.Name }} struct {
	{{- range $element := .Root.Children}}
		{{- if checkIfStruct $element }}
			{{- sanitiseName $element.Name }} {{ translateToGoType $element }} {{ generatePicTag $element.Length $element.Occurs}}
			{{- constructStruct $element }}
  		{{ else }}
			{{ sanitiseName $element.Name }} {{ translateToGoType $element }} {{ generatePicTag $element.Length $element.Occurs}}{{ generateIndexComment $element.Length $element.Occurs -}}
		{{- end }}
	{{- end }}
}

{{- range $elem := retrieveStructs }}
	{{ $elem }}
{{- end }}
`))
}

// translateToGoType translates a type into a go type.
func translateToGoType(l *lex.Record) string {
	var tag string
	switch l.Typ {
	case reflect.String:
		tag = stringTag
	case reflect.Int:
		tag = intTag
	case reflect.Uint:
		tag = uintTag
	case reflect.Float64:
		tag = floatTag
	case reflect.Struct:
		tag = sanitiseName(l.Name)
	default:
		panic(fmt.Errorf("unrecognized type %v", l.Typ))
	}
	if l.Occurs > 0 {
		tag = fmt.Sprintf("[]%s", tag)
	}
	return tag
}

// sanitiseName removes special characters from a string.
func sanitiseName(s string) string {
	return specialCharsRegexp.ReplaceAllString(s, "")
}

// checkIfStruct checks if a record is a struct.
func checkIfStruct(r *lex.Record) bool {
	return r.Typ == reflect.Struct
}
