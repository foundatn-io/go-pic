package template

import (
	"bytes"
	"fmt"
	"reflect"
	"regexp"
	"text/template"

	"github.com/pgmitche/go-pic/pkg/lex"
)

var (
	startPos = 1
	endPos   = 1

	special = regexp.MustCompile("[^a-zA-Z0-9]+")
)

func getTemplateFuncs() template.FuncMap {
	return template.FuncMap{
		"goType":       goType,
		"picTag":       picTag,
		"sanitiseName": sanitiseName,
		"indexComment": indexComment,
		"isStruct":     isStruct,
		"delve":        delve,
	}
}

// TODO: build a new template to handle the tree structure of the copybook's Root
// record
//
// for root, make struct with name
// for children in root
//   if child is struct build a new unexported struct
//		if struct has children, properties added to that struct
//   if child is any other type, follow existing behaviour

func TemplateV2() *template.Template {
	return template.Must(
		template.New("struct").
			Funcs(getTemplateFuncs()).
			Parse(`
////////////////////////////////
//     AUTOGENERATED FILE     //
// File generated with go-pic //
////////////////////////////////

// nolint
package copygen

// Copybook{{.Name}} contains a representation of your provided Copybook
type {{ .Root.Name }} struct {
	{{- range $element := .Root.Children}}
		{{ if isStruct $element }}
			type {{ sanitiseName $element.Name }} struct {
				{{ delve $element}}
			}
		{{ else }}
			{{ sanitiseName $element.Name }} {{ goType $element.Typ $element.Occurs }} {{ picTag $element.Length $element.Occurs}}{{ indexComment $element.Length $element.Occurs }} 
		{{ end }}
	{{- end }}
}
`))
}

// var copyBook = template.Must(
// 	template.New("struct").
// 		Funcs(templateFuncs).
// 		Parse(`
// ////////////////////////////////
// //     AUTOGENERATED FILE     //
// // File generated with go-pic //
// ////////////////////////////////
//
// // nolint
// package copygen
//
// // Copybook{{.Name}} contains a representation of your provided Copybook
// type Copybook{{.Name}} struct {
// 	{{- range $element := .Records}}
// 		{{sanitiseName $element.Name}} {{goType $element.Picture $element.Occurs}} {{picTag $element.Length $element.Occurs}}{{indexComment $element.Length $element.Occurs}}
// 	{{- end}}
// }
// `))

func Copybook() *template.Template {
	startPos = 1
	endPos = 1

	return TemplateV2()
}

// goType translates a type into a go type
func goType(t reflect.Kind, i int) string {
	tag := ""
	switch t {
	case reflect.String:
		tag = "string"
	case reflect.Int:
		tag = "int"
	case reflect.Uint:
		tag = "uint"
	case reflect.Float64:
		tag = "float64"
	default:
		panic(fmt.Sprintf("unrecognized type %v", t))
	}

	if i > 0 {
		tag = fmt.Sprintf("[]%s", tag)
	}

	return tag
}

func picTag(l int, i int) string {
	if i > 0 {
		return "`" + fmt.Sprintf("pic:\"%d,%d\"", l, i) + "`"
	}
	return "`" + fmt.Sprintf("pic:\"%d\"", l) + "`"
}

func indexComment(l int, i int) string {
	size := l
	if i > 0 {
		size *= i
	}

	s := startPos
	endPos += size
	startPos = endPos
	return fmt.Sprintf(" // start:%d end:%d", s, endPos-1)
}

func sanitiseName(s string) string {
	return special.ReplaceAllString(s, "")
}

func isStruct(r *lex.Record) bool {
	return r.Typ == reflect.Struct
}

func getDelveTemplate() *template.Template {
	return template.Must(
		template.New("struct").
			Funcs(getTemplateFuncs()).
			Parse(`
{{- range $element := .Children}}
	{{ if isStruct $element }}
		type {{ sanitiseName $element.Name }} struct {
			{{ delve $element}}
		}
	{{ else }}
		{{ sanitiseName $element.Name }} {{ goType $element.Typ $element.Occurs }} {{ picTag $element.Length $element.Occurs}}{{ indexComment $element.Length $element.Occurs }} 
	{{ end }}
{{- end }}`))
}

func delve(r *lex.Record) string {
	b := bytes.Buffer{}
	getDelveTemplate().Execute(&b, r)
	return b.String()
}
