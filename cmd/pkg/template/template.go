package template

import (
	"bytes"
	"fmt"
	"reflect"
	"regexp"
	"text/template"

	"github.com/foundatn-io/go-pic/pkg/lex"
)

var (
	// TODO: investigate https://github.com/masterminds/sprig for better
	// templating?
	//
	// Global state for funcMap reference when templating
	newStart   = 1
	newEnd     = 1
	savedStart = 1
	savedEnd   = 1
	cursor     = 1

	structs = make([]string, 0)

	special = regexp.MustCompile("[^a-zA-Z0-9]+")
)

func getTemplateFuncs() template.FuncMap {
	return template.FuncMap{
		"goType":       goType,
		"picTag":       newPicTag,
		"sanitiseName": sanitiseName,
		"indexComment": indexComment,
		"isStruct":     isStruct,
		"buildStruct":  buildStruct,
		"getStructs":   getStructs,
	}
}

func getTemplate() *template.Template {
	return template.Must(
		template.New("root").
			Funcs(getTemplateFuncs()).
			Parse(`
////////////////////////////////
//     AUTOGENERATED FILE     //
// File generated with go-pic //
////////////////////////////////

// nolint
package {{ .Package }}

// {{ .Root.Name }} contains a representation of your provided Copybook
type {{ .Root.Name }} struct {
	{{- range $element := .Root.Children}}
		{{- if isStruct $element }}
			{{- sanitiseName $element.Name }} {{ goType $element }} {{ picTag $element.Length $element.Occurs}}
            {{- buildStruct $element }} 
		{{ else }}
			{{ sanitiseName $element.Name }} {{ goType $element }} {{ picTag $element.Length $element.Occurs}}{{ indexComment $element.Length $element.Occurs -}} 
		{{- end }}
	{{- end }}
}

{{- range $elem := getStructs }}
	{{ $elem }}
{{- end }}
`))
}

func Copybook() *template.Template {
	newStart = 1
	newEnd = 1
	structs = make([]string, 0)

	return getTemplate()
}

// goType translates a type into a go type
func goType(l *lex.Record) string {
	tag := ""
	switch l.Typ {
	case reflect.String:
		tag = "string"
	case reflect.Int:
		tag = "int"
	case reflect.Uint:
		tag = "uint"
	case reflect.Float64:
		tag = "float64"
	case reflect.Struct:
		tag = sanitiseName(l.Name)
	default:
		panic(fmt.Sprintf("unrecognized type %v", l.Typ))
	}

	if l.Occurs > 0 {
		tag = fmt.Sprintf("[]%s", tag)
	}

	return tag
}

func newPicTag(length int, elemCount int) string {
	// tag values
	start := newStart
	size := length
	if elemCount > 0 {
		size *= elemCount
	}
	end := start + (size - 1)

	// manipulate global state :(
	newEnd = end
	newStart = newEnd + 1
	if elemCount > 0 {
		return "`" + fmt.Sprintf("pic:\"%d,%d,%d\"", start, end, elemCount) + "`"
	}

	return "`" + fmt.Sprintf("pic:\"%d,%d\"", start, end) + "`"
}

// FIXME: (pgmitche) index comments are being over-calculated now,
// due to struct support.
// e.g. DUMMYGROUP1's length of 63 is being calculated 3x to 1+189
// so DUMMYGROUP3 now starts at 201, instead of 64
//
// type root struct {
//	DUMMYGROUP1 DUMMYGROUP1 `pic:"63"`  // start:1 end:63
//	DUMMYGROUP3 DUMMYGROUP3 `pic:"201"` // start:190 end:390
// }
func indexComment(length int, elemCount int) string {
	size := length
	if elemCount > 0 {
		size *= elemCount
	}

	s := cursor
	e := s + size
	cursor = e
	return fmt.Sprintf(" // start:%d end:%d", s, e-1)
}

func sanitiseName(s string) string {
	return special.ReplaceAllString(s, "")
}

func isStruct(r *lex.Record) bool {
	return r.Typ == reflect.Struct
}

func getStructs() []string {
	return structs
}

// FIXME: (pgmitche) if record is struct but has no children,
// it should probably be ignored entirely
func getStructTemplate() *template.Template {
	newStart = 1
	newEnd = 1
	t, err := template.New("struct").
		Funcs(getTemplateFuncs()).
		Parse(`
// {{ sanitiseName .Name }} contains a representation of the nested group {{ .Name }}
type {{ sanitiseName .Name }} struct {
	{{- range $element := .Children}}
		{{- if isStruct $element }}
			{{ sanitiseName $element.Name }} {{ goType $element -}} {{ picTag $element.Length $element.Occurs}} 
            {{- buildStruct $element }} 
		{{- else }}
			{{ sanitiseName $element.Name }} {{ goType $element }} {{ picTag $element.Length $element.Occurs}} {{ indexComment $element.Length $element.Occurs -}}
		{{- end }}
	{{- end }}
}`)
	if err != nil {
		panic(err)
	}

	return t
}

// FIXME: (pgmitche) if record is struct but has no children,
// it should probably be ignored entirely
func buildStruct(r *lex.Record) string {
	savedStart = newStart
	savedEnd = newEnd
	b := bytes.Buffer{}
	if err := getStructTemplate().Execute(&b, r); err != nil {
		panic(err)
	}

	structs = append(structs, b.String())
	newStart = savedStart
	newEnd = savedEnd
	return ""
}
